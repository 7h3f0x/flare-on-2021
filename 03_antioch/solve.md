# 03_antioch

## Given files

We are given the file `antioch.tar`. This is a docker image in tar form. This
can be loaded by using:

```sh
docker load < antioch.tar
```

On running the container, it runs the `/AntiochOS` binary at the root of the
container's filesystem. This binary can be fetched using:

```sh
docker cp <container-id>:/AntiochOS .
```

## Code Analysis

```c
__int64 start()
{
  char *AntiochOS_version_info; // rax
  char cmp_buf[32]; // [rsp+0h] [rbp-B8h] BYREF
  char mostly_inp_buf[152]; // [rsp+20h] [rbp-98h] BYREF

  AntiochOS_version_info = get_AntiochOS_version_info();
  write(STDOUT_FILENO, AntiochOS_version_info, 37LL);// prints : 'AntiochOS, version 1.32 (build 1975)\n'
  copy_help_msg_to_buf(mostly_inp_buf);
  write(STDOUT_FILENO, mostly_inp_buf, 19LL);   // prints: 'Type help for help\n'
  while ( 1 )
  {
    *(_WORD *)mostly_inp_buf = ' >';
    write(STDOUT_FILENO, mostly_inp_buf, 2LL);  // prints prompt '> '
    if ( !read(STDIN_FILENO, mostly_inp_buf, 128LL) )// read user input
      break;
    copy_quit_to_buf(cmp_buf);
    if ( !(unsigned int)strncmp(mostly_inp_buf, cmp_buf, 5LL) )// if input was 'quit\n'
      break;
    copy_help_to_buf(cmp_buf);
    if ( !(unsigned int)strncmp(mostly_inp_buf, cmp_buf, 5LL) )// if input was 'help\n'
    {
      print_help();
    }
    else
    {
      copy_consult_to_buf(cmp_buf);
      if ( !(unsigned int)strncmp(mostly_inp_buf, cmp_buf, 8LL) )// if input was 'consult\n'
      {
        consult();
      }
      else
      {
        copy_approach_to_buf(cmp_buf);
        if ( !(unsigned int)strncmp(mostly_inp_buf, cmp_buf, 9LL) )// if input was 'approach\n'
          approach();
      }
    }
  }
  return exit(0);
}
```

The `_start` function of the program prints the initial version info message and
the information about the help command.

Then it has a while(1) loop which takes bytes input from the user and compares
it to some predefined strings and then does corresponding actions for them. A
brief description:

1. quit:
   This breaks out of the while loop, which leads to an exit call.

2. help:
   This prints the help message using the `print_help` function.

3. consult:
   This calls the `consult` function which prints some output based on files of
   the form(`*.dat`) in the current folder

4. approach:
   This calls the `approach` function. This basically asks the user for a name,
   quest and favourite color. Then it hashes the name and color and checks for
   them against some values in memory. If found, then it prints a number.

So, the interesting functions are:
- consult
- approach

### Function: consult

```c
__int64 consult()
{
  int v0; // er14
  char *consult_the_book_of_armaments_buf; // rax
  signed int fd; // eax
  unsigned int also_fd; // er13
  char *v4; // rax
  char *v5; // rdx
  __int64 i; // rax
  char v7; // dl
  char v9[8]; // [rsp+8h] [rbp-2030h] BYREF
  char v10[4096]; // [rsp+10h] [rbp-2028h] BYREF
  char v11[4096]; // [rsp+1010h] [rbp-1028h] BYREF
  char v12; // [rsp+2010h] [rbp-28h] BYREF

  v0 = 'a';
  *(_QWORD *)v9 = 0x7461642E2ELL;               // '..dat\x00\x00\x00'
  memset(v11, 0, sizeof(v11));
  consult_the_book_of_armaments_buf = get_consult_the_book_of_armaments_buf();
  write(STDOUT_FILENO, consult_the_book_of_armaments_buf, 31LL);// prints: 'Consult the Book of Armaments!\n'
  sleep(2);
  do
  {
    while ( 1 )
    {
      v9[0] = v0;
      fd = open(v9);
      also_fd = fd;
      if ( fd >= 0 )
        break;
      if ( (_BYTE)++v0 == '{' )
        goto LABEL_7;
    }
    read(fd, v10, 4096LL);
    close(also_fd);
    v4 = v11;
    v5 = v10;
    do
      *v4++ ^= *v5++;
    while ( v4 != &v12 );
    ++v0;
  }
  while ( (_BYTE)v0 != '{' );
LABEL_7:
  if ( !(_BYTE)xmmword_404100 )
  {
    xmmword_404100 = (__int128)_mm_load_si128((const __m128i *)&xmmword_402240);
    xmmword_404110 = xmmword_404100;
    xmmword_404120 = xmmword_404100;
    xmmword_404130 = xmmword_404100;
    xmmword_404140 = xmmword_404100;
    xmmword_404150 = xmmword_404100;
    xmmword_404160 = xmmword_404100;
    xmmword_404170 = xmmword_404100;
    xmmword_404180 = xmmword_404100;
    xmmword_404190 = xmmword_404100;
    xmmword_4041A0 = xmmword_404100;
    xmmword_4041B0 = xmmword_404100;
    xmmword_4041C0 = xmmword_404100;
    xmmword_4041D0 = xmmword_404100;
    xmmword_4041E0 = xmmword_404100;
    xmmword_4041F0 = xmmword_404100;
    copy_some_string_to_buf((char *)&xmmword_404100);
  }
  for ( i = 0LL; i != 4096; ++i )
  {
    v7 = '\n';
    if ( (i & 0xF) != 0xF )
      v7 = *((_BYTE *)&xmmword_404100 + (unsigned __int8)v11[i]);
    v11[i] = v7;
  }
  return write(STDOUT_FILENO, v11, 4096LL);
}
```

This function loops through files of the form: `[a-z].dat`, copies data from the
file (if it exists) into a buffer `v10`, and then XOR's the memory of the buffer
`v11` with this buffer. The buffer is initially set to 0s.

It then uses the memory:

```
.rodata:0000000000402240 xmmword_402240  xmmword '................'
```

And copies it to a bunch of xmmwords in global memory. The total size of these
globals summed up is the size of the `v11` buffer. It then performs a simple
addition shift based change to the global memory of these xmmwords with a
newline at every 16th position. This modified / decrypted buffer is then printed
out to the screen.

Thus the files `[a-z].dat` are used as decryption keys with a buffer filled
completely with `.`s

### Function: approach

```c
__int64 approach()
{
  __int64 hash_struct_idx; // rbx
  char *approach_gorge_buf; // rax
  int v2; // eax
  int v3; // eax
  struct hash_type *hash_iter; // rdx
  int name_hash; // ecx
  int v6; // eax
  int v7; // er8
  struct hash_type *p_hash; // rax
  char num; // al
  char *right_off_you_go_buf; // rax
  char new_line_char; // [rsp+Fh] [rbp-B9h] BYREF
  char v13[32]; // [rsp+10h] [rbp-B8h] BYREF
  char inp_buf[152]; // [rsp+30h] [rbp-98h] BYREF

  hash_struct_idx = 0LL;
  new_line_char = '\n';
  approach_gorge_buf = get_approach_gorge_buf();// returns: 'Approach the Gorge of Eternal Peril!\n'
  write(STDOUT_FILENO, approach_gorge_buf, 37LL);
  sleep(1);
  copy_what_is_your_name_to_buf(v13);
  write(STDOUT_FILENO, v13, 19LL);              // prints: 'What is your name? '
  v2 = read(STDIN_FILENO, inp_buf, 128LL);
  v3 = custom_hash(inp_buf, v2);
  hash_iter = &hashes_arr[1];
  name_hash = 0xB59395A9;                       // hashes_arr[0].name_hash = 0xB59395A9
  while ( name_hash != v3 )                     // loop through the hash_type array, searching for a matching name_hash
  {
    hash_struct_idx = (unsigned int)(hash_struct_idx + 1);
    if ( (_DWORD)hash_struct_idx == 30 )
      return write(STDOUT_FILENO, "...AAARGH\n\n", 11LL);
    name_hash = hash_iter->name_hash;
    ++hash_iter;
  }
  copy_what_is_your_quest_to_buf(v13);
  write(STDOUT_FILENO, v13, 20LL);              // prints: 'What is your quest? '
  if ( read(STDIN_FILENO, inp_buf, 128LL) > 1 )
  {
    copy_what_is_your_fav_color_to_buf(v13);
    write(STDOUT_FILENO, v13, 29LL);            // prints 'What is your favorite color? '
    v6 = read(STDIN_FILENO, inp_buf, 128LL);
    v7 = custom_hash(inp_buf, v6);
    p_hash = &hashes_arr[hash_struct_idx];
    if ( p_hash->color_hash == v7 )             // if the color_hash entry of the struct in the array whose name_hash matched
                                                // is equal to the hash of the color we just input
    {
      num = p_hash->num;                        // the num field in the struct whose name_hash and color_hash were matched
      if ( num > 0 )
      {
        convert_num_to_string_in_buf(num, inp_buf);
        right_off_you_go_buf = get_right_off_you_go_buf();// returns 'Right. Off you go. #'
        write(STDOUT_FILENO, right_off_you_go_buf, 20LL);
        write(STDOUT_FILENO, inp_buf, strlen(inp_buf));
        return write(STDOUT_FILENO, &new_line_char, 1LL);// putchar('\n')
      }
    }
  }
  return write(STDOUT_FILENO, "...AAARGH\n\n", 11LL);
}
```

The program first asks for a name. It then hashes it (with function labelled
`custom_hash`).

```c
// actually crc32 with lookup_tbl
__int64 __fastcall custom_hash(char *buf, int buf_len)
{
  char *v2; // rsi
  unsigned int v3; // eax
  char v4; // dl

  if ( buf_len <= 0 )
    return 0LL;
  v2 = &buf[buf_len - 1 + 1];
  v3 = -1;
  do
  {
    v4 = *buf++;
    v3 = dword_402260[(unsigned __int8)(v3 ^ v4)] ^ (v3 >> 8);
  }
  while ( v2 != buf );
  return ~v3;
}
```

This is actually a
[**CRC32**](https://web.mit.edu/freebsd/head/sys/libkern/crc32.c) hash
implemented using a looup table(I found out after I had already re-implemented
it).

Next, the program uses an array of structures of the form as shown below:

```c
struct hash_type
{
  int name_hash;
  int color_hash;
  int num;
};
```

The array begins at `0x402000`, but starts referencing the array from the first
index, as it hardcodes the `name_hash` value for the 1st entry. It checks
whether our hash matches any of the `name_hash` values in this array's
structures.

If some value does match, it asks us for a quest, which just has to be
something(it is not checked against anything). Next, it asks us for our favorite
color, hashes it with the same **CRC32** algorithm. Then checks it against the
`color_hash` value in the struct whose `name_hash` value matched out entered
name's hash. If they are equal, it prints:

> Right. Off you go. #`<num>`

Where `num` is the field of the same struct whose entries matched our name and
color hashes.

## Solution

At first, I did not get the **Monty Python and the Holy Grail**
[reference](https://en.wikipedia.org/wiki/Monty_Python_and_the_Holy_Grail). But,
after searching around a bit, I found out that the `approach` function
referenced [this](https://montypython.fandom.com/wiki/Bridge_of_Death). I used
the same answers which are mentioned there, to get this:


```
> approach
Approach the Gorge of Eternal Peril!
What is your name? Sir Lancelot
What is your quest? asdf
What is your favorite color? Blue
Right. Off you go. #18
```

So, most probably the other hashes were like this too. Eventually, after some
digging, I found that the original `antioch.tar` file had many layers, most of
which contained the files of the form `[a-z].dat`. But, these layers were not
part of the actual container created due to the way it's manifest was. I
manually untarred every layer, and tried to run the binary using the individual
layers, then using the consult feature, but to no luck.

Finally, I started to look at `#flare-on8` on twitter, and after some digging
found out that the number field was related to the order in which these layers
were to be used. I found out, using some brute-force and grepping, that, the
names of the `author` field in the layers corresponded to the names whose hashes
would equal `name_hash` of the structs.

- Finding names:
  In the untarred location, run:
  ```sh
  grep -r -oE '"author":".*?","config' | grep -oE '"[^"]*?"' | grep -v author
  ```
  Then add `\n` at the end of these in the brute force (to emulate newline)


```cpp
unsigned int hashes_arr[] = { 0xB59395A9, 0x1BB5AB29, 0x0e, 1593692235, 1065642184, 18, 3974989264, 2194816328, 2, 3629421076, 4665061, 29, 741278285, 3382730922, 12, 25842226, 2413109, 13, 1924696627, 2169988627, 20, 1732510946, 1365893417, 11, 813331381, 3848331582, 28, 323389188, 593028265, 21, 2499168027, 3593738835, 5, 3986804597, 3136983525, 24, 3148616269, 2794939421, 25, 4144489667, 4011349571, 7, 3607255407, 2042792213, 10, 2258700360, 1494257628, 1, 3594539804, 4013810152, 19, 2070306227, 2745762736, 3, 2870157772, 4008569559, 4, 1331717848, 2626305287, 17, 627066826, 1082506910, 9, 1070145235, 932530633, 8, 2753867748, 4018606919, 27, 1426653658, 33352811, 16, 279092781, 3881850538, 22, 1456195679, 896473704, 15, 2162156454, 2634724662, 30, 3864515809, 3035233584, 23, 732029396, 3194411288, 26, 2100496539, 1740764549, 6, 0, 0, 0, 0, 0, 0 };
const size_t hashes_arr_len = sizeof(hashes_arr) / sizeof(hashes_arr[0]);

unsigned int dword_402260[] = { 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117 };
const size_t dword_402260_len = sizeof(dword_402260) / sizeof(dword_402260[0]);
char* names[] = {
    "Trojan Rabbit\n",
    "Squire Concorde\n",
    "Black Knight\n",
    "Lady of the Lake\n",
    "Tim the Enchanter\n",
    "Chicken of Bristol\n",
    "Prince Herbert\n",
    "Sir Bors\n",
    "Bridge Keeper\n",
    "Zoot\n",
    "Sir Gawain\n",
    "Rabbit of Caerbannog\n",
    "Sir Robin\n",
    "Green Knight\n",
    "Sir Bedevere\n",
    "Sir Ector\n",
    "A Famous Historian\n",
    "Sir Lancelot\n",
    "Roger the Shrubber\n",
    "Sir Not-Appearing-in-this-Film\n",
    "Brother Maynard\n",
    "Dragon of Angnor\n",
    "Dinky\n",
    "Legendary Black Beast of Argh\n",
    "Dennis the Peasant\n",
    "King Arthur\n",
    "Inspector End Of Film\n",
    "Sir Gallahad\n",
    "Miss Islington\n",
    "Squire Patsy\n",
};

long custom_hash(char* buf, int len) {
    if (len <= 0)
        return 0;
    unsigned int res = -1;
    for (int i = 0; i < len; ++i) {
        res = dword_402260[(std::uint8_t)(res ^ buf[i])] ^ (res >> 8);
    }
    return ~res;
}
int main (int argc, char *argv[])
{
    for (int i = 0; i < sizeof(names)/sizeof(names[0]); ++i) {
        int v3 = custom_hash(names[i], strlen(names[i]));
        std::cout << names[i];
        for (int i = 0; i < hashes_arr_len / 3; ++i) {
            if (hashes_arr[i*3] == v3) {
                std::cout << hashes_arr[i*3 + 2] << std::endl;
                break;
            }
        }
    }
    return 0;
}

```

The result:

```
Trojan Rabbit 11
Squire Concorde 9
Black Knight 29
Lady of the Lake 19
Tim the Enchanter 3
Chicken of Bristol 12
Prince Herbert 22
Sir Bors 2
Bridge Keeper 14
Zoot 8
Sir Gawain 15
Rabbit of Caerbannog 20
Sir Robin 7
Green Knight 10
Sir Bedevere 6
Sir Ector 25
A Famous Historian 17
Sir Lancelot 18
Roger the Shrubber 13
Sir Not-Appearing-in-this-Film 21
Brother Maynard 5
Dragon of Angnor 4
Dinky 28
Legendary Black Beast of Argh 16
Dennis the Peasant 27
King Arthur 23
Inspector End Of Film 24
Sir Gallahad 30
Miss Islington 1
Squire Patsy 26
```

Thus, I now knew what to do. I had to find the num values for all the names.
Then trace those names back to layer ids, and then in increasing order of num
values, untar the layers in that order in the same folder, run the `AntiochOS`
binary and use the consult feature. This spit out the flag in a monstrous ascii
art form, with each character below the previous one.

- Content of `res.txt`:
  Use, this command to get the layer id's in the same order (run in the untarred
  directory):

  ```sh
  grep -r -oE '"author":".*?","config'
  ```

  Final result, after combining:

  ```
  6b4e128697aa0459a6caba2088f6f77efaaf29d407ec6b58939c9bc7814688ad Trojan Rabbit 11
  81f28623cca429f9914e21790722d0351737f8ad3e823619a4f7019be72e2195 Squire Concorde 9
  cfd7ddb31ce44bb24b373645876ac7ea372da1f3f31758f2321cc8f5b29884fb Black Knight 29
  a435765bcd8745561460979b270878a3e7c729fae46d9e878f4c2d42e5096a44 Lady of the Lake 19
  4c33f90f25ea2ab1352efb77794ecc424883181cf8e6644946255738ac9f5dbd Tim the Enchanter 3
  bfefc1bdf8b980a525f58da1550b56daa67bae66b56e49b993fff139faa1472c Chicken of Bristol 12
  e1a9333f9eccfeae42acec6ac459b9025fe6097c065ffeefe5210867e1e2317d Prince Herbert 22
  ea12384be264c32ec1db0986247a8d4b2231bf017742313c01b05a7e431d9c26 Sir Bors 2
  f9621328166de01de73b4044edb9030b3ad3d5dbc61c0b79e26f177e9123d184 Bridge Keeper 14
  b5f502d32c018d6b2ee6a61f30306f9b46dad823ba503eea5b403951209fd59b Zoot 8
  58da659c7d1c5a0c3447cb97cd6ffb12027c734bfba32de8b9b362475fe92fae Sir Gawain 15
  cd27ad9a438a7eef05f5b5d99e2454225693e63aba29ce8553800fed23575040 Rabbit of Caerbannog 20
  754ee87063ee108c1f939cd3a28980a03b700f3c3967df8058831edad2743fd7 Sir Robin 7
  76531a907cdecf03c8ac404d91cbcabd438a226161e621fab103a920600372a8 Green Knight 10
  7d643931f34d73776e9169551798e1c4ca3b4c37b730143e88171292dbe99264 Sir Bedevere 6
  303dfd1f7447a80322cc8a8677941da7116fbf0cea56e7d36a4f563c6f22e867 Sir Ector 25
  49fb821d2bf6d6841ac7cf5005a6f18c4c76f417ac8a53d9e6b48154b5aa1e76 A Famous Historian 17
  fd8bf3c084c5dd42159f9654475f5861add943905d0ad1d3672f39e014757470 Sir Lancelot 18
  1c5d28d6564aed0316526e8bb2d79a436b45530d2493967c8083fea2b2e518ce Roger the Shrubber 13
  8e11477e79016a17e5cde00abc06523856a7db9104c0234803d30a81c50d2b71 Sir Not-Appearing-in-this-Film 21
  e5254dec4c7d10c15e16b41994ca3cf0c5e2b2a56c9d4dc2ef053eeff24333ff Brother Maynard 5
  09e6fff53d6496d170aaa9bc88bd39e17c8e5c13ee9066935b089ab0312635ef Dragon of Angnor 4
  25e171d6ac47c26159b26cd192a90d5d37e733eb16e68d3579df364908db30f2 Dinky 28
  9a31bad171ad7e8009fba41193d339271fc51f992b8d574c501cae1bfa6c3fe2 Legendary Black Beast of Argh 16
  2b363180ec5d5862b2a348db3069b51d79d4e7a277d5cf5e4afe2a54fc04730e Dennis the Peasant 27
  e6c2557dc0ff4173baee856cbc5641d5b19706ddb4368556fcdb046f36efd2e2 King Arthur 23
  fadf53f0ae11908b89dffc3123e662d31176b0bb047182bfec51845d1e81beb9 Inspector End Of Film 24
  a2de31788db95838a986271665b958ac888d78559aa07e55d2a98fc3baecf6e6 Sir Gallahad 30
  b75ea3e81881c5d36261f64d467c7eb87cd694c85dd15df946601330f36763a4 Miss Islington 1
  f2ebdc667cbafc2725421d3c02babc957da2370fbd019a9e1993d8b0409f86dd Squire Patsy 26
  ```

Combined solution script:

> originally, i just did all this manually

```python
import os
import shutil

if os.path.exists('result'):
    shutil.rmtree('result')

os.mkdir('result')
os.chdir('result')

os.system("tar xvf ../antioch.tar")

res = []
with open('../res.txt', "r") as f:
    for line in f.read().splitlines():
        if not line:
            continue
        l = line.split()
        res.append((l[0], int(l[-1])))

res = sorted(res, key=lambda x: x[1])

for r in res:
    os.system("tar xvf {}/layer.tar".format(r[0]))

os.system('echo "consult" | ../AntiochOS')

```

Output:

```
AntiochOS, version 1.32 (build 1975)
Type help for help
> consult
Consult the Book of Armaments!
...............
...............
...............
...............
...............
...............
...............
...............
...............
....______.....
...|..____|....
...|.|__.......
...|..__|......
...|.|.........
...|_|.........
...............
...............
...._..........
...(_).........
...._..........
...|.|.........
...|.|.........
...|_|.........
...............
...............
...............
...............
...__...__.....
...\.\././.....
....\.V./......
.....\_/.......
...............
...............
...............
...............
.....___.......
..../._.\......
...|..__/......
....\___|......
...............
...............
...............
...............
....______.....
...|______|....
...............
...............
...............
...............
...._____......
...|_..._|.....
.....|.|.......
.....|.|.......
...._|.|_......
...|_____|.....
...............
...............
...............
...............
....___........
.../.__|.......
...\__.\.......
...|___/.......
...............
...............
...............
...............
....______.....
...|______|....
...............
...............
...............
...............
...._____......
...|..__.\.....
...|.|__).|....
...|.._../.....
...|.|.\.\.....
...|_|..\_\....
...............
...............
...._..........
...(_).........
...._..........
...|.|.........
...|.|.........
...|_|.........
...............
...............
...............
...............
.....__._......
..../._`.|.....
...|.(_|.|.....
....\__,.|.....
.....__/.|.....
....|___/......
...._..........
...|.|.........
...|.|__.......
...|.'_.\......
...|.|.|.|.....
...|_|.|_|.....
...............
...............
...._..........
...|.|.........
...|.|_........
...|.__|.......
...|.|_........
....\__|.......
...............
...............
...............
...............
....______.....
...|______|....
...............
...............
...............
...............
.....____......
..../.__.\.....
...|.|..|.|....
...|.|..|.|....
...|.|__|.|....
....\____/.....
...............
...............
...............
...............
...._..._......
...|.|.|.|.....
...|.|_|.|.....
....\__,_|.....
...............
...............
...._..........
...|.|.........
...|.|_........
...|.__|.......
...|.|_........
....\__|.......
...............
...............
...............
......____.....
...../.__.\....
...././._`.|...
...|.|.(_|.|...
....\.\__,_|...
.....\____/....
...............
.....__........
..../._|.......
...|.|_........
...|.._|.......
...|.|.........
...|_|.........
...............
...............
...._..........
...|.|.........
...|.|.........
...|.|.........
...|.|.........
...|_|.........
...............
...............
...............
...............
.....__._......
..../._`.|.....
...|.(_|.|.....
....\__,_|.....
...............
...............
...............
...............
...._.__.......
...|.'__|......
...|.|.........
...|_|.........
...............
...............
...............
...............
.....___.......
..../._.\......
...|..__/......
....\___|......
...............
...............
...............
...............
....______.....
...|______|....
...............
...............
...............
...............
...............
...............
.....___.......
..../._.\......
...|.(_).|.....
....\___/......
...............
...............
...............
...............
...._.__.......
...|.'_.\......
...|.|.|.|.....
...|_|.|_|.....
...............
...............
...............
...............
...............
...............
...._..........
...(_).........
...............
...............
...............
...............
.....___.......
..../.__|......
...|.(__.......
....\___|......
...............
...............
...............
...............
.....___.......
..../._.\......
...|.(_).|.....
....\___/......
...............
...............
...............
...............
...._.__.___...
...|.'_.`._.\..
...|.|.|.|.|.|.
...|_|.|_|.|_|.
...............
...............
...............
...............
...............
...............
...............
...............
...............
```


## flag

> `Five-Is-Right-Out@flare-on.com`

<!-- vim:nowrap
-->

